"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/gameLogic.ts":
/*!******************************!*\
  !*** ./src/lib/gameLogic.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areBoardsEqual: function() { return /* binding */ areBoardsEqual; },\n/* harmony export */   flipPanels: function() { return /* binding */ flipPanels; },\n/* harmony export */   generateProblem: function() { return /* binding */ generateProblem; },\n/* harmony export */   getStageForLevel: function() { return /* binding */ getStageForLevel; }\n/* harmony export */ });\n// src/lib/gameLogic.ts\n// --- 型定義 ---\n/**\n * 指定された座標のパネルと、その周囲のパネルを反転させる\n * @param board - 現在の盤面\n * @param row - タップされた行\n * @param col - タップされた列\n * @returns 新しい盤面\n */ const flipPanels = (board, row, col)=>{\n    const newBoard = board.map((r)=>[\n            ...r\n        ]);\n    const size = newBoard.length;\n    for(let r = row - 1; r <= row + 1; r++){\n        for(let c = col - 1; c <= col + 1; c++){\n            if (r >= 0 && r < size && c >= 0 && c < size) {\n                newBoard[r][c] = newBoard[r][c] === \"O\" ? \"X\" : \"O\";\n            }\n        }\n    }\n    return newBoard;\n};\n/**\n * 2つの盤面が一致するかどうかを判定する\n * @param board1 - 盤面1\n * @param board2 - 盤面2\n * @returns 一致する場合は true\n */ const areBoardsEqual = (board1, board2)=>{\n    if (board1.length !== board2.length) return false;\n    for(let i = 0; i < board1.length; i++){\n        if (board1[i].length !== board2[i].length) return false;\n        for(let j = 0; j < board1[i].length; j++){\n            if (board1[i][j] !== board2[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\nconst stages = [\n    {\n        size: 4,\n        taps: 1,\n        levels: 10\n    },\n    {\n        size: 4,\n        taps: 2,\n        levels: 10\n    },\n    {\n        size: 5,\n        taps: 1,\n        levels: 10\n    },\n    {\n        size: 5,\n        taps: 2,\n        levels: 10\n    },\n    {\n        size: 6,\n        taps: 2,\n        levels: 10\n    },\n    {\n        size: 6,\n        taps: 3,\n        levels: 10\n    },\n    {\n        size: 7,\n        taps: 3,\n        levels: 10\n    },\n    {\n        size: 7,\n        taps: 4,\n        levels: 10\n    },\n    {\n        size: 8,\n        taps: 3,\n        levels: 10\n    },\n    {\n        size: 8,\n        taps: 4,\n        levels: 10\n    }\n];\nconst getStageForLevel = (level)=>{\n    if (level <= 0) return 0;\n    let tempLevel = level;\n    let stageNumber = 1;\n    for (const stage of stages){\n        if (tempLevel <= stage.levels) {\n            return stageNumber;\n        }\n        tempLevel -= stage.levels;\n        stageNumber++;\n    }\n    return stageNumber; // For levels beyond the defined stages\n};\nconst generateProblem = (level)=>{\n    let size;\n    let requiredTaps;\n    let tempLevel = level;\n    let stageFound = false;\n    for (const stage of stages){\n        if (tempLevel <= stage.levels) {\n            size = stage.size;\n            requiredTaps = stage.taps;\n            stageFound = true;\n            break;\n        }\n        tempLevel -= stage.levels;\n    }\n    // If level exceeds defined stages, extrapolate\n    if (!stageFound) {\n        size = 6 + Math.floor((level - 50) / 10);\n        requiredTaps = 1 + (level - 50) % 5;\n        if (size > 9) size = 9; // Max size\n    }\n    // 1. 全て 'O' の目標盤面を作成\n    let targetBoard = Array(size).fill(0).map(()=>Array(size).fill(\"O\"));\n    // 2. 規定回数タップして初期盤面を生成する\n    let currentBoard = targetBoard;\n    const tapHistory = [];\n    for(let i = 0; i < requiredTaps; i++){\n        // 同じ場所を2回タップしないように、簡易的な重複チェック\n        let row, col;\n        do {\n            row = Math.floor(Math.random() * size);\n            col = Math.floor(Math.random() * size);\n        }while (tapHistory.some((t)=>t.row === row && t.col === col));\n        tapHistory.push({\n            row,\n            col\n        });\n        currentBoard = flipPanels(currentBoard, row, col);\n    }\n    // 3. 目標盤面が複雑になるように、少しランダムに反転させる\n    // これにより、同じ設定（サイズ、タップ数）でも異なる問題が生成される\n    let initialBoard = currentBoard;\n    const complexity = Math.floor(Math.random() * (size / 2)); // 盤面サイズに応じた複雑性\n    for(let i = 0; i < complexity; i++){\n        const row = Math.floor(Math.random() * size);\n        const col = Math.floor(Math.random() * size);\n        initialBoard = flipPanels(initialBoard, row, col);\n        targetBoard = flipPanels(targetBoard, row, col);\n    }\n    return {\n        level,\n        size,\n        initialBoard,\n        targetBoard,\n        requiredTaps\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ2FtZUxvZ2ljLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx1QkFBdUI7QUFFdkIsY0FBYztBQVlkOzs7Ozs7Q0FNQyxHQUNNLE1BQU1BLGFBQWEsQ0FBQ0MsT0FBY0MsS0FBYUM7SUFDcEQsTUFBTUMsV0FBV0gsTUFBTUksR0FBRyxDQUFDQyxDQUFBQSxJQUFLO2VBQUlBO1NBQUU7SUFDdEMsTUFBTUMsT0FBT0gsU0FBU0ksTUFBTTtJQUU1QixJQUFLLElBQUlGLElBQUlKLE1BQU0sR0FBR0ksS0FBS0osTUFBTSxHQUFHSSxJQUFLO1FBQ3ZDLElBQUssSUFBSUcsSUFBSU4sTUFBTSxHQUFHTSxLQUFLTixNQUFNLEdBQUdNLElBQUs7WUFDdkMsSUFBSUgsS0FBSyxLQUFLQSxJQUFJQyxRQUFRRSxLQUFLLEtBQUtBLElBQUlGLE1BQU07Z0JBQzVDSCxRQUFRLENBQUNFLEVBQUUsQ0FBQ0csRUFBRSxHQUFHTCxRQUFRLENBQUNFLEVBQUUsQ0FBQ0csRUFBRSxLQUFLLE1BQU0sTUFBTTtZQUNsRDtRQUNGO0lBQ0Y7SUFDQSxPQUFPTDtBQUNULEVBQUU7QUFFRjs7Ozs7Q0FLQyxHQUNNLE1BQU1NLGlCQUFpQixDQUFDQyxRQUFlQztJQUM1QyxJQUFJRCxPQUFPSCxNQUFNLEtBQUtJLE9BQU9KLE1BQU0sRUFBRSxPQUFPO0lBQzVDLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJRixPQUFPSCxNQUFNLEVBQUVLLElBQUs7UUFDdEMsSUFBSUYsTUFBTSxDQUFDRSxFQUFFLENBQUNMLE1BQU0sS0FBS0ksTUFBTSxDQUFDQyxFQUFFLENBQUNMLE1BQU0sRUFBRSxPQUFPO1FBQ2xELElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJSCxNQUFNLENBQUNFLEVBQUUsQ0FBQ0wsTUFBTSxFQUFFTSxJQUFLO1lBQ3pDLElBQUlILE1BQU0sQ0FBQ0UsRUFBRSxDQUFDQyxFQUFFLEtBQUtGLE1BQU0sQ0FBQ0MsRUFBRSxDQUFD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LGVBQWU7SUFDMUUsSUFBSSxJQUFJTSxJQUFFLEdBQUdBLElBQUl5QixZQUFZekIsSUFBSztRQUNoQyxNQUFNWCxNQUFNd0IsS0FBS0MsS0FBSyxDQUFDRCxLQUFLTyxNQUFNLEtBQUsxQjtRQUN2QyxNQUFNSixNQUFNdUIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLTyxNQUFNLEtBQUsxQjtRQUN2QzhCLGVBQWVyQyxXQUFXcUMsY0FBY25DLEtBQUtDO1FBQzdDeUIsY0FBYzVCLFdBQVc0QixhQUFhMUIsS0FBS0M7SUFDN0M7SUFHQSxPQUFPO1FBQ0xnQjtRQUNBWjtRQUNBOEI7UUFDQVQ7UUFDQUo7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9nYW1lTG9naWMudHM/NjA0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGliL2dhbWVMb2dpYy50c1xuXG4vLyAtLS0g5Z6L5a6a576pIC0tLVxuZXhwb3J0IHR5cGUgUGFuZWxTdGF0ZSA9ICdPJyB8ICdYJzsgLy8gTzog6KGoLCBYOiDoo49cbmV4cG9ydCB0eXBlIEJvYXJkID0gUGFuZWxTdGF0ZVtdW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvYmxlbSB7XG4gIGxldmVsOiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbiAgaW5pdGlhbEJvYXJkOiBCb2FyZDtcbiAgdGFyZ2V0Qm9hcmQ6IEJvYXJkO1xuICByZXF1aXJlZFRhcHM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiDmjIflrprjgZXjgozjgZ/luqfmqJnjga7jg5Hjg43jg6vjgajjgIHjgZ3jga7lkajlm7Ljga7jg5Hjg43jg6vjgpLlj43ou6LjgZXjgZvjgotcbiAqIEBwYXJhbSBib2FyZCAtIOePvuWcqOOBruebpOmdolxuICogQHBhcmFtIHJvdyAtIOOCv+ODg+ODl+OBleOCjOOBn+ihjFxuICogQHBhcmFtIGNvbCAtIOOCv+ODg+ODl+OBleOCjOOBn+WIl1xuICogQHJldHVybnMg5paw44GX44GE55uk6Z2iXG4gKi9cbmV4cG9ydCBjb25zdCBmbGlwUGFuZWxzID0gKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogQm9hcmQgPT4ge1xuICBjb25zdCBuZXdCb2FyZCA9IGJvYXJkLm1hcChyID0+IFsuLi5yXSk7XG4gIGNvbnN0IHNpemUgPSBuZXdCb2FyZC5sZW5ndGg7XG5cbiAgZm9yIChsZXQgciA9IHJvdyAtIDE7IHIgPD0gcm93ICsgMTsgcisrKSB7XG4gICAgZm9yIChsZXQgYyA9IGNvbCAtIDE7IGMgPD0gY29sICsgMTsgYysrKSB7XG4gICAgICBpZiAociA+PSAwICYmIHIgPCBzaXplICYmIGMgPj0gMCAmJiBjIDwgc2l6ZSkge1xuICAgICAgICBuZXdCb2FyZFtyXVtjXSA9IG5ld0JvYXJkW3JdW2NdID09PSAnTycgPyAnWCcgOiAnTyc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdCb2FyZDtcbn07XG5cbi8qKlxuICogMuOBpOOBruebpOmdouOBjOS4gOiHtOOBmeOCi+OBi+OBqeOBhuOBi+OCkuWIpOWumuOBmeOCi1xuICogQHBhcmFtIGJvYXJkMSAtIOebpOmdojFcbiAqIEBwYXJhbSBib2FyZDIgLSDnm6TpnaIyXG4gKiBAcmV0dXJucyDkuIDoh7TjgZnjgovloLTlkIjjga8gdHJ1ZVxuICovXG5leHBvcnQgY29uc3QgYXJlQm9hcmRzRXF1YWwgPSAoYm9hcmQxOiBCb2FyZCwgYm9hcmQyOiBCb2FyZCk6IGJvb2xlYW4gPT4ge1xuICBpZiAoYm9hcmQxLmxlbmd0aCAhPT0gYm9hcmQyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvYXJkMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChib2FyZDFbaV0ubGVuZ3RoICE9PSBib2FyZDJbaV0ubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBib2FyZDFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChib2FyZDFbaV1bal0gIT09IGJvYXJkMltpXVtqXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiDmlrDjgZfjgYTllY/poYzjgpLnlJ/miJDjgZnjgotcbiAqIEBwYXJhbSBsZXZlbCAtIOePvuWcqOOBruODrOODmeODqyAoMeOBi+OCiSlcbiAqIEByZXR1cm5zIOeUn+aIkOOBleOCjOOBn+WVj+mhjOOCquODluOCuOOCp+OCr+ODiFxuICovXG5cbmludGVyZmFjZSBTdGFnZSB7XG4gIHNpemU6IG51bWJlcjtcbiAgdGFwczogbnVtYmVyO1xuICBsZXZlbHM6IG51bWJlcjtcbn1cblxuY29uc3Qgc3RhZ2VzOiBTdGFnZVtdID0gW1xuICAgIHsgc2l6ZTogNCwgdGFwczogMSwgbGV2ZWxzOiAxMCB9LCAvLyBMdiAxLTEwXG4gICAgeyBzaXplOiA0LCB0YXBzOiAyLCBsZXZlbHM6IDEwIH0sIC8vIEx2IDExLTIwXG4gICAgeyBzaXplOiA1LCB0YXBzOiAxLCBsZXZlbHM6IDEwIH0sIC8vIEx2IDIxLTMwXG4gICAgeyBzaXplOiA1LCB0YXBzOiAyLCBsZXZlbHM6IDEwIH0sIC8vIEx2IDMxLTQwXG4gICAgeyBzaXplOiA2LCB0YXBzOiAyLCBsZXZlbHM6IDEwIH0sIC8vIEx2IDQxLTUwXG4gICAgeyBzaXplOiA2LCB0YXBzOiAzLCBsZXZlbHM6IDEwIH0sIC8vIEx2IDUxLTYwXG4gICAgeyBzaXplOiA3LCB0YXBzOiAzLCBsZXZlbHM6IDEwIH0sIC8vIEx2IDYxLTcwXG4gICAgeyBzaXplOiA3LCB0YXBzOiA0LCBsZXZlbHM6IDEwIH0sIC8vIEx2IDcxLTgwXG4gICAgeyBzaXplOiA4LCB0YXBzOiAzLCBsZXZlbHM6IDEwIH0sIC8vIEx2IDgxLTkwXG4gICAgeyBzaXplOiA4LCB0YXBzOiA0LCBsZXZlbHM6IDEwIH0sIC8vIEx2IDkxLTEwMFxuXTtcblxuZXhwb3J0IGNvbnN0IGdldFN0YWdlRm9yTGV2ZWwgPSAobGV2ZWw6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgaWYgKGxldmVsIDw9IDApIHJldHVybiAwO1xuICAgIGxldCB0ZW1wTGV2ZWwgPSBsZXZlbDtcbiAgICBsZXQgc3RhZ2VOdW1iZXIgPSAxO1xuICAgIGZvciAoY29uc3Qgc3RhZ2Ugb2Ygc3RhZ2VzKSB7XG4gICAgICAgIGlmICh0ZW1wTGV2ZWwgPD0gc3RhZ2UubGV2ZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhZ2VOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcExldmVsIC09IHN0YWdlLmxldmVscztcbiAgICAgICAgc3RhZ2VOdW1iZXIrKztcbiAgICB9XG4gICAgcmV0dXJuIHN0YWdlTnVtYmVyOyAvLyBGb3IgbGV2ZWxzIGJleW9uZCB0aGUgZGVmaW5lZCBzdGFnZXNcbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVByb2JsZW0gPSAobGV2ZWw6IG51bWJlcik6IFByb2JsZW0gPT4ge1xuICBsZXQgc2l6ZTogbnVtYmVyO1xuICBsZXQgcmVxdWlyZWRUYXBzOiBudW1iZXI7XG5cbiAgbGV0IHRlbXBMZXZlbCA9IGxldmVsO1xuICBsZXQgc3RhZ2VGb3VuZCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHN0YWdlIG9mIHN0YWdlcykge1xuICAgIGlmICh0ZW1wTGV2ZWwgPD0gc3RhZ2UubGV2ZWxzKSB7XG4gICAgICBzaXplID0gc3RhZ2Uuc2l6ZTtcbiAgICAgIHJlcXVpcmVkVGFwcyA9IHN0YWdlLnRhcHM7XG4gICAgICBzdGFnZUZvdW5kID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0ZW1wTGV2ZWwgLT0gc3RhZ2UubGV2ZWxzO1xuICB9XG5cbiAgLy8gSWYgbGV2ZWwgZXhjZWVkcyBkZWZpbmVkIHN0YWdlcywgZXh0cmFwb2xhdGVcbiAgaWYgKCFzdGFnZUZvdW5kKSB7XG4gICAgICBzaXplID0gNiArIE1hdGguZmxvb3IoKGxldmVsIC0gNTApIC8gMTApO1xuICAgICAgcmVxdWlyZWRUYXBzID0gMSArICgobGV2ZWwgLSA1MCkgJSA1KTtcbiAgICAgIGlmIChzaXplID4gOSkgc2l6ZSA9IDk7IC8vIE1heCBzaXplXG4gIH1cblxuICAvLyAxLiDlhajjgaYgJ08nIOOBruebruaomeebpOmdouOCkuS9nOaIkFxuICBsZXQgdGFyZ2V0Qm9hcmQ6IEJvYXJkID0gQXJyYXkoc2l6ZSkuZmlsbCgwKS5tYXAoKCkgPT4gQXJyYXkoc2l6ZSkuZmlsbCgnTycpKTtcbiAgXG4gIC8vIDIuIOimj+WumuWbnuaVsOOCv+ODg+ODl+OBl+OBpuWIneacn+ebpOmdouOCkueUn+aIkOOBmeOCi1xuICBsZXQgY3VycmVudEJvYXJkID0gdGFyZ2V0Qm9hcmQ7XG4gIGNvbnN0IHRhcEhpc3Rvcnk6IHtyb3c6IG51bWJlciwgY29sOiBudW1iZXJ9W10gPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVpcmVkVGFwczsgaSsrKSB7XG4gICAgLy8g5ZCM44GY5aC05omA44KSMuWbnuOCv+ODg+ODl+OBl+OBquOBhOOCiOOBhuOBq+OAgeewoeaYk+eahOOBqumHjeikh+ODgeOCp+ODg+OCr1xuICAgIGxldCByb3c6IG51bWJlciwgY29sOiBudW1iZXI7XG4gICAgZG8ge1xuICAgICAgcm93ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2l6ZSk7XG4gICAgICBjb2wgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzaXplKTtcbiAgICB9IHdoaWxlICh0YXBIaXN0b3J5LnNvbWUodCA9PiB0LnJvdyA9PT0gcm93ICYmIHQuY29sID09PSBjb2wpKTtcbiAgICBcbiAgICB0YXBIaXN0b3J5LnB1c2goeyByb3csIGNvbCB9KTtcbiAgICBjdXJyZW50Qm9hcmQgPSBmbGlwUGFuZWxzKGN1cnJlbnRCb2FyZCwgcm93LCBjb2wpO1xuICB9XG5cbiAgLy8gMy4g55uu5qiZ55uk6Z2i44GM6KSH6ZuR44Gr44Gq44KL44KI44GG44Gr44CB5bCR44GX44Op44Oz44OA44Og44Gr5Y+N6Lui44GV44Gb44KLXG4gIC8vIOOBk+OCjOOBq+OCiOOCiuOAgeWQjOOBmOioreWumu+8iOOCteOCpOOCuuOAgeOCv+ODg+ODl+aVsO+8ieOBp+OCgueVsOOBquOCi+WVj+mhjOOBjOeUn+aIkOOBleOCjOOCi1xuICBsZXQgaW5pdGlhbEJvYXJkID0gY3VycmVudEJvYXJkO1xuICBjb25zdCBjb21wbGV4aXR5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHNpemUgLyAyKSk7IC8vIOebpOmdouOCteOCpOOCuuOBq+W/nOOBmOOBn+ikh+mbkeaAp1xuICBmb3IobGV0IGk9MDsgaSA8IGNvbXBsZXhpdHk7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNpemUpO1xuICAgIGNvbnN0IGNvbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNpemUpO1xuICAgIGluaXRpYWxCb2FyZCA9IGZsaXBQYW5lbHMoaW5pdGlhbEJvYXJkLCByb3csIGNvbCk7XG4gICAgdGFyZ2V0Qm9hcmQgPSBmbGlwUGFuZWxzKHRhcmdldEJvYXJkLCByb3csIGNvbCk7XG4gIH1cblxuXG4gIHJldHVybiB7XG4gICAgbGV2ZWwsXG4gICAgc2l6ZSxcbiAgICBpbml0aWFsQm9hcmQsXG4gICAgdGFyZ2V0Qm9hcmQsXG4gICAgcmVxdWlyZWRUYXBzLFxuICB9O1xufTtcblxuIl0sIm5hbWVzIjpbImZsaXBQYW5lbHMiLCJib2FyZCIsInJvdyIsImNvbCIsIm5ld0JvYXJkIiwibWFwIiwiciIsInNpemUiLCJsZW5ndGgiLCJjIiwiYXJlQm9hcmRzRXF1YWwiLCJib2FyZDEiLCJib2FyZDIiLCJpIiwiaiIsInN0YWdlcyIsInRhcHMiLCJsZXZlbHMiLCJnZXRTdGFnZUZvckxldmVsIiwibGV2ZWwiLCJ0ZW1wTGV2ZWwiLCJzdGFnZU51bWJlciIsInN0YWdlIiwiZ2VuZXJhdGVQcm9ibGVtIiwicmVxdWlyZWRUYXBzIiwic3RhZ2VGb3VuZCIsIk1hdGgiLCJmbG9vciIsInRhcmdldEJvYXJkIiwiQXJyYXkiLCJmaWxsIiwiY3VycmVudEJvYXJkIiwidGFwSGlzdG9yeSIsInJhbmRvbSIsInNvbWUiLCJ0IiwicHVzaCIsImluaXRpYWxCb2FyZCIsImNvbXBsZXhpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/gameLogic.ts\n"));

/***/ })

});