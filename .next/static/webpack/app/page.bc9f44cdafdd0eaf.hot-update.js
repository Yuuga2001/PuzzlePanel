"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/gameLogic.ts":
/*!******************************!*\
  !*** ./src/lib/gameLogic.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areBoardsEqual: function() { return /* binding */ areBoardsEqual; },\n/* harmony export */   flipPanels: function() { return /* binding */ flipPanels; },\n/* harmony export */   generateProblem: function() { return /* binding */ generateProblem; }\n/* harmony export */ });\n// src/lib/gameLogic.ts\n// --- 型定義 ---\n/**\n * 指定された座標のパネルと、その周囲のパネルを反転させる\n * @param board - 現在の盤面\n * @param row - タップされた行\n * @param col - タップされた列\n * @returns 新しい盤面\n */ const flipPanels = (board, row, col)=>{\n    const newBoard = board.map((r)=>[\n            ...r\n        ]);\n    const size = newBoard.length;\n    for(let r = row - 1; r <= row + 1; r++){\n        for(let c = col - 1; c <= col + 1; c++){\n            if (r >= 0 && r < size && c >= 0 && c < size) {\n                newBoard[r][c] = newBoard[r][c] === \"O\" ? \"X\" : \"O\";\n            }\n        }\n    }\n    return newBoard;\n};\n/**\n * 2つの盤面が一致するかどうかを判定する\n * @param board1 - 盤面1\n * @param board2 - 盤面2\n * @returns 一致する場合は true\n */ const areBoardsEqual = (board1, board2)=>{\n    if (board1.length !== board2.length) return false;\n    for(let i = 0; i < board1.length; i++){\n        if (board1[i].length !== board2[i].length) return false;\n        for(let j = 0; j < board1[i].length; j++){\n            if (board1[i][j] !== board2[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\nconst stages = [\n    {\n        size: 4,\n        taps: 1,\n        levels: 10\n    },\n    {\n        size: 4,\n        taps: 2,\n        levels: 10\n    },\n    {\n        size: 5,\n        taps: 1,\n        levels: 10\n    },\n    {\n        size: 5,\n        taps: 2,\n        levels: 10\n    },\n    {\n        size: 6,\n        taps: 2,\n        levels: 10\n    },\n    {\n        size: 6,\n        taps: 3,\n        levels: 10\n    },\n    {\n        size: 7,\n        taps: 3,\n        levels: 10\n    },\n    {\n        size: 7,\n        taps: 4,\n        levels: 10\n    },\n    {\n        size: 8,\n        taps: 3,\n        levels: 10\n    },\n    {\n        size: 8,\n        taps: 4,\n        levels: 10\n    }\n];\nconst generateProblem = (level)=>{\n    let size;\n    let requiredTaps;\n    let tempLevel = level;\n    let stageFound = false;\n    for (const stage of stages){\n        if (tempLevel <= stage.levels) {\n            size = stage.size;\n            requiredTaps = stage.taps;\n            stageFound = true;\n            break;\n        }\n        tempLevel -= stage.levels;\n    }\n    // If level exceeds defined stages, extrapolate\n    if (!stageFound) {\n        size = 6 + Math.floor((level - 50) / 10);\n        requiredTaps = 1 + (level - 50) % 5;\n        if (size > 9) size = 9; // Max size\n    }\n    // 1. 全て 'O' の目標盤面を作成\n    let targetBoard = Array(size).fill(0).map(()=>Array(size).fill(\"O\"));\n    // 2. 規定回数タップして初期盤面を生成する\n    let currentBoard = targetBoard;\n    const tapHistory = [];\n    for(let i = 0; i < requiredTaps; i++){\n        // 同じ場所を2回タップしないように、簡易的な重複チェック\n        let row, col;\n        do {\n            row = Math.floor(Math.random() * size);\n            col = Math.floor(Math.random() * size);\n        }while (tapHistory.some((t)=>t.row === row && t.col === col));\n        tapHistory.push({\n            row,\n            col\n        });\n        currentBoard = flipPanels(currentBoard, row, col);\n    }\n    // 3. 目標盤面が複雑になるように、少しランダムに反転させる\n    // これにより、同じ設定（サイズ、タップ数）でも異なる問題が生成される\n    let initialBoard = currentBoard;\n    const complexity = Math.floor(Math.random() * (size / 2)); // 盤面サイズに応じた複雑性\n    for(let i = 0; i < complexity; i++){\n        const row = Math.floor(Math.random() * size);\n        const col = Math.floor(Math.random() * size);\n        initialBoard = flipPanels(initialBoard, row, col);\n        targetBoard = flipPanels(targetBoard, row, col);\n    }\n    return {\n        level,\n        size,\n        initialBoard,\n        targetBoard,\n        requiredTaps\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ2FtZUxvZ2ljLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHVCQUF1QjtBQUV2QixjQUFjO0FBWWQ7Ozs7OztDQU1DLEdBQ00sTUFBTUEsYUFBYSxDQUFDQyxPQUFjQyxLQUFhQztJQUNwRCxNQUFNQyxXQUFXSCxNQUFNSSxHQUFHLENBQUNDLENBQUFBLElBQUs7ZUFBSUE7U0FBRTtJQUN0QyxNQUFNQyxPQUFPSCxTQUFTSSxNQUFNO0lBRTVCLElBQUssSUFBSUYsSUFBSUosTUFBTSxHQUFHSSxLQUFLSixNQUFNLEdBQUdJLElBQUs7UUFDdkMsSUFBSyxJQUFJRyxJQUFJTixNQUFNLEdBQUdNLEtBQUtOLE1BQU0sR0FBR00sSUFBSztZQUN2QyxJQUFJSCxLQUFLLEtBQUtBLElBQUlDLFFBQVFFLEtBQUssS0FBS0EsSUFBSUYsTUFBTTtnQkFDNUNILFFBQVEsQ0FBQ0UsRUFBRSxDQUFDRyxFQUFFLEdBQUdMLFFBQVEsQ0FBQ0UsRUFBRSxDQUFDRyxFQUFFLEtBQUssTUFBTSxNQUFNO1lBQ2xEO1FBQ0Y7SUFDRjtJQUNBLE9BQU9MO0FBQ1QsRUFBRTtBQUVGOzs7OztDQUtDLEdBQ00sTUFBTU0saUJBQWlCLENBQUNDLFFBQWVDO0lBQzVDLElBQUlELE9BQU9ILE1BQU0sS0FBS0ksT0FBT0osTUFBTSxFQUFFLE9BQU87SUFDNUMsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlGLE9BQU9ILE1BQU0sRUFBRUssSUFBSztRQUN0QyxJQUFJRixNQUFNLENBQUNFLEVBQUUsQ0FBQ0wsTUFBTSxLQUFLSSxNQUFNLENBQUNDLEVBQUUsQ0FBQ0wsTUFBTSxFQUFFLE9BQU87UUFDbEQsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlILE1BQU0sQ0FBQ0UsRUFBRSxDQUFDTCxNQUFNLEVBQUVNLElBQUs7WUFDekMsSUFBSUgsTUFBTSxDQUFDRSxFQUFFLENBQUNDLEVBQUUsS0FBS0YsTUFBTSxDQUFDQyxFQUFFLENBQUND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O0lBR0EsT0FBTztRQUNMZ0I7UUFDQVo7UUFDQTRCO1FBQ0FUO1FBQ0FOO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvZ2FtZUxvZ2ljLnRzPzYwNDIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpYi9nYW1lTG9naWMudHNcblxuLy8gLS0tIOWei+Wumue+qSAtLS1cbmV4cG9ydCB0eXBlIFBhbmVsU3RhdGUgPSAnTycgfCAnWCc7IC8vIE86IOihqCwgWDog6KOPXG5leHBvcnQgdHlwZSBCb2FyZCA9IFBhbmVsU3RhdGVbXVtdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb2JsZW0ge1xuICBsZXZlbDogbnVtYmVyO1xuICBzaXplOiBudW1iZXI7XG4gIGluaXRpYWxCb2FyZDogQm9hcmQ7XG4gIHRhcmdldEJvYXJkOiBCb2FyZDtcbiAgcmVxdWlyZWRUYXBzOiBudW1iZXI7XG59XG5cbi8qKlxuICog5oyH5a6a44GV44KM44Gf5bqn5qiZ44Gu44OR44ON44Or44Go44CB44Gd44Gu5ZGo5Zuy44Gu44OR44ON44Or44KS5Y+N6Lui44GV44Gb44KLXG4gKiBAcGFyYW0gYm9hcmQgLSDnj77lnKjjga7nm6TpnaJcbiAqIEBwYXJhbSByb3cgLSDjgr/jg4Pjg5fjgZXjgozjgZ/ooYxcbiAqIEBwYXJhbSBjb2wgLSDjgr/jg4Pjg5fjgZXjgozjgZ/liJdcbiAqIEByZXR1cm5zIOaWsOOBl+OBhOebpOmdolxuICovXG5leHBvcnQgY29uc3QgZmxpcFBhbmVscyA9IChib2FyZDogQm9hcmQsIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IEJvYXJkID0+IHtcbiAgY29uc3QgbmV3Qm9hcmQgPSBib2FyZC5tYXAociA9PiBbLi4ucl0pO1xuICBjb25zdCBzaXplID0gbmV3Qm9hcmQubGVuZ3RoO1xuXG4gIGZvciAobGV0IHIgPSByb3cgLSAxOyByIDw9IHJvdyArIDE7IHIrKykge1xuICAgIGZvciAobGV0IGMgPSBjb2wgLSAxOyBjIDw9IGNvbCArIDE7IGMrKykge1xuICAgICAgaWYgKHIgPj0gMCAmJiByIDwgc2l6ZSAmJiBjID49IDAgJiYgYyA8IHNpemUpIHtcbiAgICAgICAgbmV3Qm9hcmRbcl1bY10gPSBuZXdCb2FyZFtyXVtjXSA9PT0gJ08nID8gJ1gnIDogJ08nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3Qm9hcmQ7XG59O1xuXG4vKipcbiAqIDLjgaTjga7nm6TpnaLjgYzkuIDoh7TjgZnjgovjgYvjganjgYbjgYvjgpLliKTlrprjgZnjgotcbiAqIEBwYXJhbSBib2FyZDEgLSDnm6TpnaIxXG4gKiBAcGFyYW0gYm9hcmQyIC0g55uk6Z2iMlxuICogQHJldHVybnMg5LiA6Ie044GZ44KL5aC05ZCI44GvIHRydWVcbiAqL1xuZXhwb3J0IGNvbnN0IGFyZUJvYXJkc0VxdWFsID0gKGJvYXJkMTogQm9hcmQsIGJvYXJkMjogQm9hcmQpOiBib29sZWFuID0+IHtcbiAgaWYgKGJvYXJkMS5sZW5ndGggIT09IGJvYXJkMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2FyZDEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYm9hcmQxW2ldLmxlbmd0aCAhPT0gYm9hcmQyW2ldLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYm9hcmQxW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoYm9hcmQxW2ldW2pdICE9PSBib2FyZDJbaV1bal0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICog5paw44GX44GE5ZWP6aGM44KS55Sf5oiQ44GZ44KLXG4gKiBAcGFyYW0gbGV2ZWwgLSDnj77lnKjjga7jg6zjg5njg6sgKDHjgYvjgokpXG4gKiBAcmV0dXJucyDnlJ/miJDjgZXjgozjgZ/llY/poYzjgqrjg5bjgrjjgqfjgq/jg4hcbiAqL1xuXG5pbnRlcmZhY2UgU3RhZ2Uge1xuICBzaXplOiBudW1iZXI7XG4gIHRhcHM6IG51bWJlcjtcbiAgbGV2ZWxzOiBudW1iZXI7XG59XG5cbmNvbnN0IHN0YWdlczogU3RhZ2VbXSA9IFtcbiAgICB7IHNpemU6IDQsIHRhcHM6IDEsIGxldmVsczogMTAgfSwgLy8gTHYgMS0xMFxuICAgIHsgc2l6ZTogNCwgdGFwczogMiwgbGV2ZWxzOiAxMCB9LCAvLyBMdiAxMS0yMFxuICAgIHsgc2l6ZTogNSwgdGFwczogMSwgbGV2ZWxzOiAxMCB9LCAvLyBMdiAyMS0zMFxuICAgIHsgc2l6ZTogNSwgdGFwczogMiwgbGV2ZWxzOiAxMCB9LCAvLyBMdiAzMS00MFxuICAgIHsgc2l6ZTogNiwgdGFwczogMiwgbGV2ZWxzOiAxMCB9LCAvLyBMdiA0MS01MFxuICAgIHsgc2l6ZTogNiwgdGFwczogMywgbGV2ZWxzOiAxMCB9LCAvLyBMdiA1MS02MFxuICAgIHsgc2l6ZTogNywgdGFwczogMywgbGV2ZWxzOiAxMCB9LCAvLyBMdiA2MS03MFxuICAgIHsgc2l6ZTogNywgdGFwczogNCwgbGV2ZWxzOiAxMCB9LCAvLyBMdiA3MS04MFxuICAgIHsgc2l6ZTogOCwgdGFwczogMywgbGV2ZWxzOiAxMCB9LCAvLyBMdiA4MS05MFxuICAgIHsgc2l6ZTogOCwgdGFwczogNCwgbGV2ZWxzOiAxMCB9LCAvLyBMdiA5MS0xMDBcbl07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVByb2JsZW0gPSAobGV2ZWw6IG51bWJlcik6IFByb2JsZW0gPT4ge1xuICBsZXQgc2l6ZTogbnVtYmVyO1xuICBsZXQgcmVxdWlyZWRUYXBzOiBudW1iZXI7XG5cbiAgbGV0IHRlbXBMZXZlbCA9IGxldmVsO1xuICBsZXQgc3RhZ2VGb3VuZCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHN0YWdlIG9mIHN0YWdlcykge1xuICAgIGlmICh0ZW1wTGV2ZWwgPD0gc3RhZ2UubGV2ZWxzKSB7XG4gICAgICBzaXplID0gc3RhZ2Uuc2l6ZTtcbiAgICAgIHJlcXVpcmVkVGFwcyA9IHN0YWdlLnRhcHM7XG4gICAgICBzdGFnZUZvdW5kID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0ZW1wTGV2ZWwgLT0gc3RhZ2UubGV2ZWxzO1xuICB9XG5cbiAgLy8gSWYgbGV2ZWwgZXhjZWVkcyBkZWZpbmVkIHN0YWdlcywgZXh0cmFwb2xhdGVcbiAgaWYgKCFzdGFnZUZvdW5kKSB7XG4gICAgICBzaXplID0gNiArIE1hdGguZmxvb3IoKGxldmVsIC0gNTApIC8gMTApO1xuICAgICAgcmVxdWlyZWRUYXBzID0gMSArICgobGV2ZWwgLSA1MCkgJSA1KTtcbiAgICAgIGlmIChzaXplID4gOSkgc2l6ZSA9IDk7IC8vIE1heCBzaXplXG4gIH1cblxuICAvLyAxLiDlhajjgaYgJ08nIOOBruebruaomeebpOmdouOCkuS9nOaIkFxuICBsZXQgdGFyZ2V0Qm9hcmQ6IEJvYXJkID0gQXJyYXkoc2l6ZSkuZmlsbCgwKS5tYXAoKCkgPT4gQXJyYXkoc2l6ZSkuZmlsbCgnTycpKTtcbiAgXG4gIC8vIDIuIOimj+WumuWbnuaVsOOCv+ODg+ODl+OBl+OBpuWIneacn+ebpOmdouOCkueUn+aIkOOBmeOCi1xuICBsZXQgY3VycmVudEJvYXJkID0gdGFyZ2V0Qm9hcmQ7XG4gIGNvbnN0IHRhcEhpc3Rvcnk6IHtyb3c6IG51bWJlciwgY29sOiBudW1iZXJ9W10gPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVpcmVkVGFwczsgaSsrKSB7XG4gICAgLy8g5ZCM44GY5aC05omA44KSMuWbnuOCv+ODg+ODl+OBl+OBquOBhOOCiOOBhuOBq+OAgeewoeaYk+eahOOBqumHjeikh+ODgeOCp+ODg+OCr1xuICAgIGxldCByb3c6IG51bWJlciwgY29sOiBudW1iZXI7XG4gICAgZG8ge1xuICAgICAgcm93ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2l6ZSk7XG4gICAgICBjb2wgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzaXplKTtcbiAgICB9IHdoaWxlICh0YXBIaXN0b3J5LnNvbWUodCA9PiB0LnJvdyA9PT0gcm93ICYmIHQuY29sID09PSBjb2wpKTtcbiAgICBcbiAgICB0YXBIaXN0b3J5LnB1c2goeyByb3csIGNvbCB9KTtcbiAgICBjdXJyZW50Qm9hcmQgPSBmbGlwUGFuZWxzKGN1cnJlbnRCb2FyZCwgcm93LCBjb2wpO1xuICB9XG5cbiAgLy8gMy4g55uu5qiZ55uk6Z2i44GM6KSH6ZuR44Gr44Gq44KL44KI44GG44Gr44CB5bCR44GX44Op44Oz44OA44Og44Gr5Y+N6Lui44GV44Gb44KLXG4gIC8vIOOBk+OCjOOBq+OCiOOCiuOAgeWQjOOBmOioreWumu+8iOOCteOCpOOCuuOAgeOCv+ODg+ODl+aVsO+8ieOBp+OCgueVsOOBquOCi+WVj+mhjOOBjOeUn+aIkOOBleOCjOOCi1xuICBsZXQgaW5pdGlhbEJvYXJkID0gY3VycmVudEJvYXJkO1xuICBjb25zdCBjb21wbGV4aXR5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHNpemUgLyAyKSk7IC8vIOebpOmdouOCteOCpOOCuuOBq+W/nOOBmOOBn+ikh+mbkeaAp1xuICBmb3IobGV0IGk9MDsgaSA8IGNvbXBsZXhpdHk7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNpemUpO1xuICAgIGNvbnN0IGNvbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNpemUpO1xuICAgIGluaXRpYWxCb2FyZCA9IGZsaXBQYW5lbHMoaW5pdGlhbEJvYXJkLCByb3csIGNvbCk7XG4gICAgdGFyZ2V0Qm9hcmQgPSBmbGlwUGFuZWxzKHRhcmdldEJvYXJkLCByb3csIGNvbCk7XG4gIH1cblxuXG4gIHJldHVybiB7XG4gICAgbGV2ZWwsXG4gICAgc2l6ZSxcbiAgICBpbml0aWFsQm9hcmQsXG4gICAgdGFyZ2V0Qm9hcmQsXG4gICAgcmVxdWlyZWRUYXBzLFxuICB9O1xufTtcblxuIl0sIm5hbWVzIjpbImZsaXBQYW5lbHMiLCJib2FyZCIsInJvdyIsImNvbCIsIm5ld0JvYXJkIiwibWFwIiwiciIsInNpemUiLCJsZW5ndGgiLCJjIiwiYXJlQm9hcmRzRXF1YWwiLCJib2FyZDEiLCJib2FyZDIiLCJpIiwiaiIsInN0YWdlcyIsInRhcHMiLCJsZXZlbHMiLCJnZW5lcmF0ZVByb2JsZW0iLCJsZXZlbCIsInJlcXVpcmVkVGFwcyIsInRlbXBMZXZlbCIsInN0YWdlRm91bmQiLCJzdGFnZSIsIk1hdGgiLCJmbG9vciIsInRhcmdldEJvYXJkIiwiQXJyYXkiLCJmaWxsIiwiY3VycmVudEJvYXJkIiwidGFwSGlzdG9yeSIsInJhbmRvbSIsInNvbWUiLCJ0IiwicHVzaCIsImluaXRpYWxCb2FyZCIsImNvbXBsZXhpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/gameLogic.ts\n"));

/***/ })

});