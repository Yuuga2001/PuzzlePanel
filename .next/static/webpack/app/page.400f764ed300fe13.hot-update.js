"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/gameLogic.ts":
/*!******************************!*\
  !*** ./src/lib/gameLogic.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areBoardsEqual: function() { return /* binding */ areBoardsEqual; },\n/* harmony export */   flipPanels: function() { return /* binding */ flipPanels; },\n/* harmony export */   generateProblem: function() { return /* binding */ generateProblem; }\n/* harmony export */ });\n// src/lib/gameLogic.ts\n// --- 型定義 ---\n/**\n * 指定された座標のパネルと、その周囲のパネルを反転させる\n * @param board - 現在の盤面\n * @param row - タップされた行\n * @param col - タップされた列\n * @returns 新しい盤面\n */ const flipPanels = (board, row, col)=>{\n    const newBoard = board.map((r)=>[\n            ...r\n        ]);\n    const size = newBoard.length;\n    for(let r = row - 1; r <= row + 1; r++){\n        for(let c = col - 1; c <= col + 1; c++){\n            if (r >= 0 && r < size && c >= 0 && c < size) {\n                newBoard[r][c] = newBoard[r][c] === \"O\" ? \"X\" : \"O\";\n            }\n        }\n    }\n    return newBoard;\n};\n/**\n * 2つの盤面が一致するかどうかを判定する\n * @param board1 - 盤面1\n * @param board2 - 盤面2\n * @returns 一致する場合は true\n */ const areBoardsEqual = (board1, board2)=>{\n    if (board1.length !== board2.length) return false;\n    for(let i = 0; i < board1.length; i++){\n        if (board1[i].length !== board2[i].length) return false;\n        for(let j = 0; j < board1[i].length; j++){\n            if (board1[i][j] !== board2[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\nconst stages = [\n    {\n        size: 4,\n        taps: 1,\n        levels: 5\n    },\n    {\n        size: 4,\n        taps: 2,\n        levels: 5\n    },\n    {\n        size: 5,\n        taps: 1,\n        levels: 5\n    },\n    {\n        size: 5,\n        taps: 2,\n        levels: 5\n    },\n    {\n        size: 4,\n        taps: 3,\n        levels: 5\n    },\n    {\n        size: 5,\n        taps: 3,\n        levels: 5\n    },\n    {\n        size: 6,\n        taps: 1,\n        levels: 3\n    },\n    {\n        size: 6,\n        taps: 2,\n        levels: 3\n    },\n    {\n        size: 6,\n        taps: 3,\n        levels: 3\n    },\n    {\n        size: 5,\n        taps: 4,\n        levels: 3\n    },\n    {\n        size: 6,\n        taps: 4,\n        levels: 3\n    }\n];\nconst generateProblem = (level)=>{\n    let size;\n    let requiredTaps;\n    let tempLevel = level;\n    let stageFound = false;\n    for (const stage of stages){\n        if (tempLevel <= stage.levels) {\n            size = stage.size;\n            requiredTaps = stage.taps;\n            stageFound = true;\n            break;\n        }\n        tempLevel -= stage.levels;\n    }\n    // If level exceeds defined stages, extrapolate\n    if (!stageFound) {\n        size = 6 + Math.floor((level - 50) / 10);\n        requiredTaps = 1 + (level - 50) % 5;\n        if (size > 9) size = 9; // Max size\n    }\n    // 1. 全て 'O' の目標盤面を作成\n    let targetBoard = Array(size).fill(0).map(()=>Array(size).fill(\"O\"));\n    // 2. 規定回数タップして初期盤面を生成する\n    let currentBoard = targetBoard;\n    const tapHistory = [];\n    for(let i = 0; i < requiredTaps; i++){\n        // 同じ場所を2回タップしないように、簡易的な重複チェック\n        let row, col;\n        do {\n            row = Math.floor(Math.random() * size);\n            col = Math.floor(Math.random() * size);\n        }while (tapHistory.some((t)=>t.row === row && t.col === col));\n        tapHistory.push({\n            row,\n            col\n        });\n        currentBoard = flipPanels(currentBoard, row, col);\n    }\n    // 3. 目標盤面が複雑になるように、少しランダムに反転させる\n    // これにより、同じ設定（サイズ、タップ数）でも異なる問題が生成される\n    let initialBoard = currentBoard;\n    const complexity = Math.floor(Math.random() * (size / 2)); // 盤面サイズに応じた複雑性\n    for(let i = 0; i < complexity; i++){\n        const row = Math.floor(Math.random() * size);\n        const col = Math.floor(Math.random() * size);\n        initialBoard = flipPanels(initialBoard, row, col);\n        targetBoard = flipPanels(targetBoard, row, col);\n    }\n    return {\n        level,\n        size,\n        initialBoard,\n        targetBoard,\n        requiredTaps\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ2FtZUxvZ2ljLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHVCQUF1QjtBQUV2QixjQUFjO0FBWWQ7Ozs7OztDQU1DLEdBQ00sTUFBTUEsYUFBYSxDQUFDQyxPQUFjQyxLQUFhQztJQUNwRCxNQUFNQyxXQUFXSCxNQUFNSSxHQUFHLENBQUNDLENBQUFBLElBQUs7ZUFBSUE7U0FBRTtJQUN0QyxNQUFNQyxPQUFPSCxTQUFTSSxNQUFNO0lBRTVCLElBQUssSUFBSUYsSUFBSUosTUFBTSxHQUFHSSxLQUFLSixNQUFNLEdBQUdJLElBQUs7UUFDdkMsSUFBSyxJQUFJRyxJQUFJTixNQUFNLEdBQUdNLEtBQUtOLE1BQU0sR0FBR00sSUFBSztZQUN2QyxJQUFJSCxLQUFLLEtBQUtBLElBQUlDLFFBQVFFLEtBQUssS0FBS0EsSUFBSUYsTUFBTTtnQkFDNUNILFFBQVEsQ0FBQ0UsRUFBRSxDQUFDRyxFQUFFLEdBQUdMLFFBQVEsQ0FBQ0UsRUFBRSxDQUFDRyxFQUFFLEtBQUssTUFBTSxNQUFNO1lBQ2xEO1FBQ0Y7SUFDRjtJQUNBLE9BQU9MO0FBQ1QsRUFBRTtBQUVGOzs7OztDQUtDLEdBQ00sTUFBTU0saUJBQWlCLENBQUNDLFFBQWVDO0lBQzVDLElBQUlELE9BQU9ILE1BQU0sS0FBS0ksT0FBT0osTUFBTSxFQUFFLE9BQU87SUFDNUMsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlGLE9BQU9ILE1BQU0sRUFBRUssSUFBSztRQUN0QyxJQUFJRixNQUFNLENBQUNFLEVBQUUsQ0FBQ0wsTUFBTSxLQUFLSSxNQUFNLENBQUNDLEVBQUUsQ0FBQ0wsTUFBTSxFQUFFLE9BQU87UUFDbEQsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlILE1BQU0sQ0FBQ0UsRUFBRSxDQUFDTCxNQUFNLEVBQUVNLElBQUs7WUFDekMsSUFBSUgsTUFBTSxDQUFDRSxFQUFFLENBQUNDLEVBQUUsS0FBS0YsTUFBTSxDQUFDQyxFQUFFLENBQUND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QUtDO1FBQzdDdUIsY0FBYzFCLFdBQVcwQixhQUFheEIsS0FBS0M7SUFDN0M7SUFHQSxPQUFPO1FBQ0xnQjtRQUNBWjtRQUNBNEI7UUFDQVQ7UUFDQU47SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9nYW1lTG9naWMudHM/NjA0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGliL2dhbWVMb2dpYy50c1xuXG4vLyAtLS0g5Z6L5a6a576pIC0tLVxuZXhwb3J0IHR5cGUgUGFuZWxTdGF0ZSA9ICdPJyB8ICdYJzsgLy8gTzog6KGoLCBYOiDoo49cbmV4cG9ydCB0eXBlIEJvYXJkID0gUGFuZWxTdGF0ZVtdW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvYmxlbSB7XG4gIGxldmVsOiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbiAgaW5pdGlhbEJvYXJkOiBCb2FyZDtcbiAgdGFyZ2V0Qm9hcmQ6IEJvYXJkO1xuICByZXF1aXJlZFRhcHM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiDmjIflrprjgZXjgozjgZ/luqfmqJnjga7jg5Hjg43jg6vjgajjgIHjgZ3jga7lkajlm7Ljga7jg5Hjg43jg6vjgpLlj43ou6LjgZXjgZvjgotcbiAqIEBwYXJhbSBib2FyZCAtIOePvuWcqOOBruebpOmdolxuICogQHBhcmFtIHJvdyAtIOOCv+ODg+ODl+OBleOCjOOBn+ihjFxuICogQHBhcmFtIGNvbCAtIOOCv+ODg+ODl+OBleOCjOOBn+WIl1xuICogQHJldHVybnMg5paw44GX44GE55uk6Z2iXG4gKi9cbmV4cG9ydCBjb25zdCBmbGlwUGFuZWxzID0gKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogQm9hcmQgPT4ge1xuICBjb25zdCBuZXdCb2FyZCA9IGJvYXJkLm1hcChyID0+IFsuLi5yXSk7XG4gIGNvbnN0IHNpemUgPSBuZXdCb2FyZC5sZW5ndGg7XG5cbiAgZm9yIChsZXQgciA9IHJvdyAtIDE7IHIgPD0gcm93ICsgMTsgcisrKSB7XG4gICAgZm9yIChsZXQgYyA9IGNvbCAtIDE7IGMgPD0gY29sICsgMTsgYysrKSB7XG4gICAgICBpZiAociA+PSAwICYmIHIgPCBzaXplICYmIGMgPj0gMCAmJiBjIDwgc2l6ZSkge1xuICAgICAgICBuZXdCb2FyZFtyXVtjXSA9IG5ld0JvYXJkW3JdW2NdID09PSAnTycgPyAnWCcgOiAnTyc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdCb2FyZDtcbn07XG5cbi8qKlxuICogMuOBpOOBruebpOmdouOBjOS4gOiHtOOBmeOCi+OBi+OBqeOBhuOBi+OCkuWIpOWumuOBmeOCi1xuICogQHBhcmFtIGJvYXJkMSAtIOebpOmdojFcbiAqIEBwYXJhbSBib2FyZDIgLSDnm6TpnaIyXG4gKiBAcmV0dXJucyDkuIDoh7TjgZnjgovloLTlkIjjga8gdHJ1ZVxuICovXG5leHBvcnQgY29uc3QgYXJlQm9hcmRzRXF1YWwgPSAoYm9hcmQxOiBCb2FyZCwgYm9hcmQyOiBCb2FyZCk6IGJvb2xlYW4gPT4ge1xuICBpZiAoYm9hcmQxLmxlbmd0aCAhPT0gYm9hcmQyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvYXJkMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChib2FyZDFbaV0ubGVuZ3RoICE9PSBib2FyZDJbaV0ubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBib2FyZDFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChib2FyZDFbaV1bal0gIT09IGJvYXJkMltpXVtqXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiDmlrDjgZfjgYTllY/poYzjgpLnlJ/miJDjgZnjgotcbiAqIEBwYXJhbSBsZXZlbCAtIOePvuWcqOOBruODrOODmeODqyAoMeOBi+OCiSlcbiAqIEByZXR1cm5zIOeUn+aIkOOBleOCjOOBn+WVj+mhjOOCquODluOCuOOCp+OCr+ODiFxuICovXG5cbmludGVyZmFjZSBTdGFnZSB7XG4gIHNpemU6IG51bWJlcjtcbiAgdGFwczogbnVtYmVyO1xuICBsZXZlbHM6IG51bWJlcjtcbn1cblxuY29uc3Qgc3RhZ2VzOiBTdGFnZVtdID0gW1xuICAgIHsgc2l6ZTogNCwgdGFwczogMSwgbGV2ZWxzOiA1IH0sIC8vIEx2IDEtNVxuICAgIHsgc2l6ZTogNCwgdGFwczogMiwgbGV2ZWxzOiA1IH0sIC8vIEx2IDYtMTBcbiAgICB7IHNpemU6IDUsIHRhcHM6IDEsIGxldmVsczogNSB9LCAvLyBMdiAxMS0xNVxuICAgIHsgc2l6ZTogNSwgdGFwczogMiwgbGV2ZWxzOiA1IH0sIC8vIEx2IDE2LTIwXG4gICAgeyBzaXplOiA0LCB0YXBzOiAzLCBsZXZlbHM6IDUgfSwgLy8gTHYgMjEtMjUgKFJldmlzaXQgc21hbGxlciBncmlkKVxuICAgIHsgc2l6ZTogNSwgdGFwczogMywgbGV2ZWxzOiA1IH0sIC8vIEx2IDI2LTMwXG4gICAgeyBzaXplOiA2LCB0YXBzOiAxLCBsZXZlbHM6IDMgfSwgLy8gTHYgMzEtMzNcbiAgICB7IHNpemU6IDYsIHRhcHM6IDIsIGxldmVsczogMyB9LCAvLyBMdiAzNC0zNlxuICAgIHsgc2l6ZTogNiwgdGFwczogMywgbGV2ZWxzOiAzIH0sIC8vIEx2IDM3LTM5XG4gICAgeyBzaXplOiA1LCB0YXBzOiA0LCBsZXZlbHM6IDMgfSwgLy8gTHYgNDAtNDJcbiAgICB7IHNpemU6IDYsIHRhcHM6IDQsIGxldmVsczogMyB9LCAvLyBMdiA0My00NVxuXTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlUHJvYmxlbSA9IChsZXZlbDogbnVtYmVyKTogUHJvYmxlbSA9PiB7XG4gIGxldCBzaXplOiBudW1iZXI7XG4gIGxldCByZXF1aXJlZFRhcHM6IG51bWJlcjtcblxuICBsZXQgdGVtcExldmVsID0gbGV2ZWw7XG4gIGxldCBzdGFnZUZvdW5kID0gZmFsc2U7XG4gIGZvciAoY29uc3Qgc3RhZ2Ugb2Ygc3RhZ2VzKSB7XG4gICAgaWYgKHRlbXBMZXZlbCA8PSBzdGFnZS5sZXZlbHMpIHtcbiAgICAgIHNpemUgPSBzdGFnZS5zaXplO1xuICAgICAgcmVxdWlyZWRUYXBzID0gc3RhZ2UudGFwcztcbiAgICAgIHN0YWdlRm91bmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRlbXBMZXZlbCAtPSBzdGFnZS5sZXZlbHM7XG4gIH1cblxuICAvLyBJZiBsZXZlbCBleGNlZWRzIGRlZmluZWQgc3RhZ2VzLCBleHRyYXBvbGF0ZVxuICBpZiAoIXN0YWdlRm91bmQpIHtcbiAgICAgIHNpemUgPSA2ICsgTWF0aC5mbG9vcigobGV2ZWwgLSA1MCkgLyAxMCk7XG4gICAgICByZXF1aXJlZFRhcHMgPSAxICsgKChsZXZlbCAtIDUwKSAlIDUpO1xuICAgICAgaWYgKHNpemUgPiA5KSBzaXplID0gOTsgLy8gTWF4IHNpemVcbiAgfVxuXG4gIC8vIDEuIOWFqOOBpiAnTycg44Gu55uu5qiZ55uk6Z2i44KS5L2c5oiQXG4gIGxldCB0YXJnZXRCb2FyZDogQm9hcmQgPSBBcnJheShzaXplKS5maWxsKDApLm1hcCgoKSA9PiBBcnJheShzaXplKS5maWxsKCdPJykpO1xuICBcbiAgLy8gMi4g6KaP5a6a5Zue5pWw44K/44OD44OX44GX44Gm5Yid5pyf55uk6Z2i44KS55Sf5oiQ44GZ44KLXG4gIGxldCBjdXJyZW50Qm9hcmQgPSB0YXJnZXRCb2FyZDtcbiAgY29uc3QgdGFwSGlzdG9yeToge3JvdzogbnVtYmVyLCBjb2w6IG51bWJlcn1bXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZWRUYXBzOyBpKyspIHtcbiAgICAvLyDlkIzjgZjloLTmiYDjgpIy5Zue44K/44OD44OX44GX44Gq44GE44KI44GG44Gr44CB57Ch5piT55qE44Gq6YeN6KSH44OB44Kn44OD44KvXG4gICAgbGV0IHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcjtcbiAgICBkbyB7XG4gICAgICByb3cgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzaXplKTtcbiAgICAgIGNvbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNpemUpO1xuICAgIH0gd2hpbGUgKHRhcEhpc3Rvcnkuc29tZSh0ID0+IHQucm93ID09PSByb3cgJiYgdC5jb2wgPT09IGNvbCkpO1xuICAgIFxuICAgIHRhcEhpc3RvcnkucHVzaCh7IHJvdywgY29sIH0pO1xuICAgIGN1cnJlbnRCb2FyZCA9IGZsaXBQYW5lbHMoY3VycmVudEJvYXJkLCByb3csIGNvbCk7XG4gIH1cblxuICAvLyAzLiDnm67mqJnnm6TpnaLjgYzopIfpm5HjgavjgarjgovjgojjgYbjgavjgIHlsJHjgZfjg6njg7Pjg4Djg6Djgavlj43ou6LjgZXjgZvjgotcbiAgLy8g44GT44KM44Gr44KI44KK44CB5ZCM44GY6Kit5a6a77yI44K144Kk44K644CB44K/44OD44OX5pWw77yJ44Gn44KC55Ww44Gq44KL5ZWP6aGM44GM55Sf5oiQ44GV44KM44KLXG4gIGxldCBpbml0aWFsQm9hcmQgPSBjdXJyZW50Qm9hcmQ7XG4gIGNvbnN0IGNvbXBsZXhpdHkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoc2l6ZSAvIDIpKTsgLy8g55uk6Z2i44K144Kk44K644Gr5b+c44GY44Gf6KSH6ZuR5oCnXG4gIGZvcihsZXQgaT0wOyBpIDwgY29tcGxleGl0eTsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2l6ZSk7XG4gICAgY29uc3QgY29sID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2l6ZSk7XG4gICAgaW5pdGlhbEJvYXJkID0gZmxpcFBhbmVscyhpbml0aWFsQm9hcmQsIHJvdywgY29sKTtcbiAgICB0YXJnZXRCb2FyZCA9IGZsaXBQYW5lbHModGFyZ2V0Qm9hcmQsIHJvdywgY29sKTtcbiAgfVxuXG5cbiAgcmV0dXJuIHtcbiAgICBsZXZlbCxcbiAgICBzaXplLFxuICAgIGluaXRpYWxCb2FyZCxcbiAgICB0YXJnZXRCb2FyZCxcbiAgICByZXF1aXJlZFRhcHMsXG4gIH07XG59O1xuXG4iXSwibmFtZXMiOlsiZmxpcFBhbmVscyIsImJvYXJkIiwicm93IiwiY29sIiwibmV3Qm9hcmQiLCJtYXAiLCJyIiwic2l6ZSIsImxlbmd0aCIsImMiLCJhcmVCb2FyZHNFcXVhbCIsImJvYXJkMSIsImJvYXJkMiIsImkiLCJqIiwic3RhZ2VzIiwidGFwcyIsImxldmVscyIsImdlbmVyYXRlUHJvYmxlbSIsImxldmVsIiwicmVxdWlyZWRUYXBzIiwidGVtcExldmVsIiwic3RhZ2VGb3VuZCIsInN0YWdlIiwiTWF0aCIsImZsb29yIiwidGFyZ2V0Qm9hcmQiLCJBcnJheSIsImZpbGwiLCJjdXJyZW50Qm9hcmQiLCJ0YXBIaXN0b3J5IiwicmFuZG9tIiwic29tZSIsInQiLCJwdXNoIiwiaW5pdGlhbEJvYXJkIiwiY29tcGxleGl0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/gameLogic.ts\n"));

/***/ })

});